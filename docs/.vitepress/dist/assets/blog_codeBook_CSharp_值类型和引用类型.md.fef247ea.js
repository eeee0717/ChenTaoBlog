import{_ as s,o as a,c as n,Q as p}from"./chunks/framework.030aafca.js";const o="/img/csharp-value-1.png",l="/img/csharp-value-2.png",_=JSON.parse('{"title":"C#中的值类型和引用类型","description":"","frontmatter":{},"headers":[],"relativePath":"blog/codeBook/CSharp/值类型和引用类型.md","filePath":"blog/codeBook/CSharp/值类型和引用类型.md","lastUpdated":1698559739000}'),e={name:"blog/codeBook/CSharp/值类型和引用类型.md"},t=p(`<h1 id="c-中的值类型和引用类型" tabindex="-1">C#中的值类型和引用类型 <a class="header-anchor" href="#c-中的值类型和引用类型" aria-label="Permalink to &quot;C#中的值类型和引用类型&quot;">​</a></h1><blockquote><p>在.NET中做的一切其实都是在和值类型或者引用类型打交道 ——《深入理解C#》</p></blockquote><h2 id="现实世界中的值和引用" tabindex="-1">现实世界中的值和引用 <a class="header-anchor" href="#现实世界中的值和引用" aria-label="Permalink to &quot;现实世界中的值和引用&quot;">​</a></h2><p>假设你在读一份非常棒的东西，希望你的朋友也去读它。那么需要为朋友提供什么才能让他读到这份资料呢？这完全取决于阅读的内容。</p><p>先假设你读的是一份真正的报纸。为了给朋友一份，需要影印报纸的全部内容并交给他。在这种情况下，我们处理的是<strong>值类型</strong>的行为。制作了副本后，各自的信息相互独立。</p><p>再假设你正在读的是一个网页。与前一次相比，这一次，唯一需要给朋友的是网页URL。这是<strong>引用类型</strong>的行为，URL代替引用。假如网页某个内容发生变化，你和朋友看见的页面都会更改。</p><hr><p>在C#和.NET中，值类型和引用类型的差异与现实世界中差别类似。.NET中的大多数类型都是引用类型，你以后创建的引用类型极有可能比值类型多很多。除了一下总结的特殊情况，类(class声明)是引用类型，而结构(struct声明)是值类型。特殊情况包括如下方面：</p><ul><li>数组类型是<strong>引用类型</strong>，即使元素类型是值类型(int是<strong>值类型</strong>,int[]仍是<strong>引用类型</strong>)</li><li>枚举(enum声明)<strong>是值类型</strong></li><li>委托类型(delegate)是<strong>引用类型</strong></li><li>接口类型(interface)是<strong>引用类型</strong>，但可用值类型实现</li></ul><h2 id="值类型和引用类型基础知识" tabindex="-1">值类型和引用类型基础知识 <a class="header-anchor" href="#值类型和引用类型基础知识" aria-label="Permalink to &quot;值类型和引用类型基础知识&quot;">​</a></h2><p>在学习值类型和引用类型时，要掌握的重要概念是一个<strong>特殊表达式的值</strong>是什么。为使问题更加具体，这里使用了表达式最常用的例子——变量。但是，同样的道理也适用于属性、方法调用、索引器和其他表达式。</p><p>对于值类型的表达式，它的值就是表达式的值，例如：表达式”2+3”的值就是5。</p><p>然而，对于引用类型的表达式，它的值是一个引用，而不是该引用所指代的对象。所以表达式String.Empty的值不是一个空字符串，而是「空字符串的引用」。</p><p>为了进一步演示这个问题，以下面为例:</p><div class="language-cs vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cs</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">Point</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">p1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Point</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">20</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#B392F0;">Point</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">p2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p1;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">Point</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">p1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Point</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">20</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6F42C1;">Point</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">p2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p1;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="`+o+'" alt="Image.png"></p><p>变量的值在它声明时的位置存储。局部变量的值总是存储在栈中，实例变量的值总是存储在实例本身存储的地方。引用类型实例总是存储在堆中，静态变量也是。</p><p>两种类型的另一鞥差异在于，值类型不可以派生出其他类型。这将导致的一个结果是，值不需要额外的信息来描述实际是什么类型，而引用类型的开头都需要包含一个数据块，它标识了对象的实际类型，同时还提供了一些其他信息。</p><p><img src="'+l+`" alt="Image.png"></p><h2 id="装箱和拆箱" tabindex="-1">装箱和拆箱 <a class="header-anchor" href="#装箱和拆箱" aria-label="Permalink to &quot;装箱和拆箱&quot;">​</a></h2><p>有时，我们就是不想使用值类型的值，就是想用一个引用。幸好，C#和.NET提供了一个装箱的机制，它允许根据值类型创建一个对象，然后使用对这个新对象的引用。在接触实际例子时，先来回顾两个重要事实：</p><p>对于引用类型的变量，它的值永远是一个引用；</p><p>对于值类型的变量，它的值永远是该类型的值。</p><div class="language-cs vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cs</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">i</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">object</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">o</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i;</span><span style="color:#6A737D;">// 装箱</span></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">j</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">)o;</span><span style="color:#6A737D;">// 拆箱</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">i</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">5</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">object</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">o</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i;</span><span style="color:#6A737D;">// 装箱</span></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">j</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">)o;</span><span style="color:#6A737D;">// 拆箱</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>i是值类型的变量，而o是引用类型的变量。将i的值赋值给o，这合理吗？</p><p>o的值必须是一个引用，而i的值是5。实际发生的情况就是装箱：CLR将运行在堆上创建一个新的对象，而o的值就是对新对象的引用，o对象的值就是对原始值的副本。</p><p>第三行执行相反的操作就是拆箱。必须告诉编译器将object拆箱成什么类型，否则会抛出异常。</p>`,27),r=[t];function c(i,y,E,d,g,h){return a(),n("div",null,r)}const b=s(e,[["render",c]]);export{_ as __pageData,b as default};
